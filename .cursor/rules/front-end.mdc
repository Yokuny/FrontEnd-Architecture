---
description: Rules for front-end development with React + Vite + TanStack
globs: *
alwaysApply: false
---
# Frontend Development Rules (React + Vite + TanStack)

## Tech Stack

Expert in React 19, Vite 7, TypeScript, TailwindCSS 4, ShadCN UI, Radix, TanStack Router, TanStack Query, Zustand, react-hook-form, zod, react-i18next.

Use TypeScript for all code. JavaScript only for config files when necessary.

Prioritize TailwindCSS utility classes for styling. Use ShadCN components instead of raw HTML with custom styles.

## Vite + React Core Features

Vite 7 with React 19 is the current stack. Key features include:

- Native ESM and lightning-fast HMR (Hot Module Replacement).
- React 19 features: use hook, Actions, and improved concurrent rendering.
- TanStack Router for type-safe file-based routing.
- TanStack Query for server state management and caching.
- Zustand for client state management.

## Code Structure and Functions

Use function declarations for React components. Use arrow functions for callbacks and inline functions.

Good:
```typescript
function UserProfile({ user }: UserProfileProps) {
  return <div>...</div>
}
```

Avoid:
```typescript
const UserProfile = ({ user }: UserProfileProps) => {...}
```

Name functions based on what they do, not the event they respond to. Be specific and semantic.

Good: `submitForm`, `deleteUser`, `closeModal`, `toggleSidebar`
Avoid: `handleClick`, `handleSubmit`, `handleChange`

Exception: Generic event handlers in reusable components can use `onEvent` pattern for props (onSelect, onClick, onChange) to match React conventions.

Use descriptive names that reveal intent. Prefer clarity over brevity.

## State Management

### Local State (useState)
Minimize useState by deriving values when possible. Don't store what you can calculate.

Group related state together. Use objects for related values or useReducer for complex state logic.

Keep state as local as possible. Lift state only when multiple components need to share it.

Use state updater functions when new state depends on previous state:
```typescript
setCount(prev => prev + 1)
```

### Global State (Zustand)
Use Zustand with `persist` middleware for global state that needs persistence.

Never use `localStorage.setItem` directly. Always use Zustand persist.

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

const useStore = create(
  persist(
    (set) => ({
      theme: 'light',
      setTheme: (theme) => set({ theme }),
    }),
    { name: 'app-storage' }
  )
);
```

### Server State (TanStack Query)
Use TanStack Query for all server state (data fetching, caching, mutations).

Centralize query keys:
```typescript
export const userKeys = {
  all: ['users'] as const,
  lists: () => [...userKeys.all, 'list'] as const,
  detail: (id: string) => [...userKeys.all, 'detail', id] as const,
};
```

## Routing (TanStack Router)

Routes are directory-based. Every route folder MUST have an `index.tsx`.

Valid route files:
- `index.tsx` - Main page for the directory
- `add.tsx` - Create new records
- `$id.tsx` - Dynamic route with ID parameter

FORBIDDEN: Using `.` for nested routes (e.g., `edit.$id.tsx`). Use directories instead.

```typescript
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/_private/users/')({
  component: UsersPage,
});
```

With search params validation:
```typescript
import { z } from 'zod';

const searchSchema = z.object({
  filter: z.string().optional(),
  page: z.number().optional(),
});

export const Route = createFileRoute('/_private/users/')({
  component: UsersPage,
  validateSearch: searchSchema,
});
```

## Data Fetching

Use TanStack Query for all data fetching. Never fetch in useEffect.

```typescript
function UsersList() {
  const { data, isLoading, error } = useQuery({
    queryKey: userKeys.lists(),
    queryFn: () => api.get('/users').then(res => res.data),
  });

  if (isLoading) return <DefaultLoading />;
  if (!data?.length) return <DefaultEmptyData />;

  return <UserTable data={data} />;
}
```

Use mutations for data modifications:
```typescript
const mutation = useMutation({
  mutationFn: (data) => api.post('/users', data),
  onSuccess: () => queryClient.invalidateQueries({ queryKey: userKeys.lists() }),
});
```

## Effects and Side Effects

Use useEffect sparingly. Most data fetching should happen via TanStack Query.

Always include all dependencies in useEffect arrays. Fix warnings, don't suppress them.

Clean up side effects properly (event listeners, subscriptions, timers).

Avoid useEffect for derived state. Calculate during render or use useMemo for expensive computations.

## Error Handling and User Feedback

Use async/await with try-catch blocks for asynchronous operations.

Always handle errors gracefully. Show user-friendly messages, never expose technical details.

Use toast notifications (Sonner) for transient feedback. Use modals for errors requiring user action.

Implement loading states for async operations. Never leave users wondering if something is happening.

Validate input on both client and server. Provide immediate feedback on validation errors.

## Form Handling

Use react-hook-form with zod for all forms:

```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const schema = z.object({
  name: z.string().min(1, 'Name is required'),
  email: z.string().email('Invalid email'),
});

function UserForm() {
  const form = useForm({
    resolver: zodResolver(schema),
  });

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* form fields */}
    </form>
  );
}
```

## Component Design

Keep components focused and single-purpose. If a component does more than one thing, split it.

Use early returns to handle edge cases and reduce nesting:
```typescript
if (!user) return <LoginPrompt />
if (isLoading) return <Spinner />
return <UserDashboard user={user} />
```

Extract complex JSX into separate components or variables for readability.

Avoid prop drilling. Use composition, context, or Zustand for deeply nested props.

## Page Structure

All pages MUST follow this structure:

```tsx
<Card>
  <CardHeader title={t('page.title')}>
    {/* Actions: buttons, filters */}
  </CardHeader>
  <CardContent>
    {/* Main content */}
  </CardContent>
  <CardFooter layout="multi | single">
    {/* Pagination */}
  </CardFooter>
</Card>
```

For common components (not pages):
- Never use Card components
- Use `<Item>`, `<ItemTitle>`, `<ItemDescription>` from `src/components/ui/item.tsx`

## Internationalization (i18n)

CRITICAL: Every UI string MUST use `t('key')` from `react-i18next`.

```typescript
import { useTranslation } from 'react-i18next';

function MyComponent() {
  const { t } = useTranslation();
  return <h1>{t('welcome.title')}</h1>;
}
```

Every key MUST exist in ALL 3 translation files:
- `src/config/translations/pt.json`
- `src/config/translations/en.json`
- `src/config/translations/es.json`

Use grep to verify key existence before creating new ones.

## Date Formatting

ALWAYS use `@/lib/formatDate` for date formatting. Never import directly from date-fns.

```typescript
// ❌ WRONG
import { format } from 'date-fns';
format(date, 'dd/MM/yyyy');

// ✅ CORRECT
import { formatDate } from '@/lib/formatDate';
formatDate(date, 'dd/MM/yyyy');
```

## Conditional Rendering and Styling

Use logical AND (&&) for simple conditionals:
```typescript
{isVisible && <Component />}
```

Use ternary operators for if-else rendering:
```typescript
{isLoading ? <Spinner /> : <Content />}
```

For conditional Tailwind classes, use clsx or cn utility:
```typescript
import { cn } from '@/lib/utils'
className={cn("base-classes", isActive && "active-classes")}
```

## Performance Optimization

Use React.lazy and dynamic imports for code splitting:
```typescript
const HeavyComponent = lazy(() => import('./HeavyComponent'))
```

Memoize expensive calculations with useMemo, not simple operations.

Use React.memo for components that re-render frequently with same props.

Optimize images: use appropriate sizes and lazy loading.

## Accessibility

Use semantic HTML (button, nav, main, article) over generic divs.

Ensure all interactive elements are keyboard accessible.

Provide alt text for images and aria-labels for icon-only buttons.

Maintain sufficient color contrast and support reduced motion preferences.

Use Radix UI and Shadcn components for accessible primitives.

## UI/UX Best Practices

Design mobile-first, enhance for larger screens.

Provide clear visual feedback for all user actions (hover states, loading, success).

Make error states helpful. Tell users what went wrong and how to fix it.

Use consistent spacing, typography, and colors throughout the app.

Anticipate and prevent user errors through good UX design.

Keep forms simple and progressively disclose complexity.

## Code Quality

Write self-documenting code. Use clear names over comments when possible.

Keep functions small and focused. If over 20-30 lines, consider refactoring.

Avoid magic numbers and strings. Use named constants.

Remove unused code, imports, and console.logs before committing.

Use Biome for consistent code style:
```bash
pnpm run format  # Biome formatting
pnpm run check   # TypeScript checking
```

## File Organization

Group related files by feature or module, not by file type.

Route folder structure:
```
src/routes/_private/{feature}/
├── index.tsx           # Main page
├── @components/        # Route-specific components
├── @consts/           # Constants, enums
├── @hooks/            # Route-specific hooks
├── @interface/        # Types, Interfaces, Zod schemas
└── @utils/            # Helper functions
```

Before creating hooks:
1. Check if it exists in `src/hooks/` (global hooks)
2. If route-specific, create in `@hooks/`

Name files consistently: PascalCase for components, camelCase for utilities and hooks.

## Charts

Use `getChartColor(index)` from `src/components/ui/chart` for chart colors.

NEVER use `mx-auto` on ChartContainer (causes ResponsiveContainer bugs).

Use `aspect-square` or `max-h-[XXXpx]` to control chart size.

Chart model files (copy, don't import):
- `GraphArea`, `GraphBarStacked`, `GraphLines`, `GraphPizza`
- `GraphProgress`, `GraphRadial`, `GraphBreakParts`
- `DefaultKPI`, `DefaultTable`

## Select Components

Use pre-built selects from `src/components/selects` (68 components available).

Common props:
- `mode`: `'single' | 'multi'`
- `value`: `string | string[]`
- `onChange`: `(value) => void`
- `disabled?`: `boolean`
- `clearable?`: `boolean`

Check existing selects before creating new ones.
